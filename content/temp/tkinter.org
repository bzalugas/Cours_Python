#+title: Tkinter pour le Puissance 4
#+language: fr
#+author: Bastien ZALUGAS
#+HTML_DOCTYPE: html5
#+options: <:nil ^:{} broken-links:mark creator:nil date:nil email:nil timestamp:nil toc:2 html-style:nil num:nil html5-fancy:t author:nil
#+setupfile: ./temp-theme.setup

* Utiliser la méthode grid pour l'interface du Puissance 4
:PROPERTIES:
:CUSTOM_ID: grid
:END:

** Ressources
:PROPERTIES:
:CUSTOM_ID: ressources
:END:
#+attr_html: :target _blank
[[https://koor.fr/Python/Tutoriel_Tkinter/tkinter_layout_grid.wp]]

** Pourquoi une Grid pour le Puissance 4 ?
:PROPERTIES:
:CUSTOM_ID: pourquoi-grid
:END:
La méthode grid sert à positionner des éléments (=widgets) dans notre écran en fonction d'un positionnement matriciel. Comme nous utilisons une matrice, c'est à dire une liste de listes, pour placer nos jetons sur le plateau, c'est la méthode la plus adaptée. Il faudra associer à chaque cellule créée le clic de la souris et la fonction qui placera le jeton.

** Etape par étape
:PROPERTIES:
:CUSTOM_ID: etapes
:END:
*** Pré-requis
Il faut déjà avoir initialisé ta grille de puissance 4 avant de paramétrer l'affichage car tu auras besoin de la taille de la grille et des éventuelles valeurs des cases.

*** Initialisation
1. Crée un objet Tk() (=window = tkinter.Tk()=).
2. Configure la fenêtre (titre, fond, etc).
3. Crée un dictionnaire vide qui contiendra tous les widgets de la grille (=widgets = {}=).
   
*** Création des widgets
1. A l'aide d'une double boucle imbriquée (pour parcourir la grille de puissance 4), il faut pour chaque case de la grille créer une cellule pour ton affichage (une cellule sera un Label()). Exemple à l'intérieur de la boucle:
   #+begin_src python
     cell = Label(window, text=" ", bg='white')
     cell.grid(row = i, column = j)
     cell.bind('<Button-1>', clic)
     # clic correspond à une fonction qui faudra définir et qui sera lancée uniquement lorsque l'on clique sur une cellule.
     widgets[(i,j)] = cell
     # utiliser le (i,j) comme clé permettra de retrouver le widget correspondant à une case de la grille de puissance 4.
   #+end_src

2. La fonction clic doit récupérer l'information de la colonne sélectionnée et lancer la fonction qui trouve la bonne ligne pour placer le jeton. Exemple de début de la fonction :
    #+begin_src python
      def clic(event):
	  cell = event.widget
	  col = int(cell.grid_info()['column'])
	  ligne = trouver_ligne(col)
	  # Le reste à implémenter
    #+end_src

* Autre solution sans la méthode grid
:PROPERTIES:
:CUSTOM_ID: solution2
:END:
** Stockage des formes du canvas dans une liste
:PROPERTIES:
:CUSTOM_ID: stockage-formes
:END:
Au moment de créer les formes dans le canvas, tu peux les stocker dans une liste de la même forme que celle qui contient la grille du puissance 4. Exemple :
#+begin_src python
canvas = Canvas(root, ...)
formes = []
for i in range(len(grille)):
    formes.append([])
    for j in range(len(grille[i])):
        formes[i].append(canvas.create_oval(...))
#+end_src

** Détection de la forme cliquée dans un canvas
:PROPERTIES:
:CUSTOM_ID: detection-forme
:END:
On peut détecter assez facilement sur quelle forme était la souris lorsqu'elle a déclenché l'évènement ='<Button-1>'= en utilisant la méthode disponible dans notre canvas =canvas.find_closest(x,y)=.
*** Démonstration
- Tu peux utiliser la méthode bind directement dans le canvas après l'avoir créé :
  #+begin_src python
canvas.bind('<Button-1>', click)
  #+end_src

- Dans la fonction =click(event)=, tu retrouves l'élément le plus proche du clic et tu retrouves les coordonnées correspondantes grâce à la liste ou au dictionnaire dans laquelle/lequel tu as mis tous les items créés au fur et à mesure :
  #+begin_src python
item = canvas.find_closest(event.x, event.y)
colonne = None
#Retrouver la position de la forme dans la liste de stockage
for i in range(len(formes)):
    for j in range(len(formes[i])):
        if formes[i][j] == item:
           colonne = j
           break
  #+end_src
Après cette étape, tu as retrouvé la colonne de la forme sur laquelle on a cliqué et tu peux utiliser tes fonctions codées auparavant avec cette information.
** Cas d'une forme sous une autre
:PROPERTIES:
:CUSTOM_ID: find-below
:END:
Normalement, la méthode =find_closest()= devrait suffire mais il se peut que tu aies besoin de trouver quelle forme se trouve en-dessous de celle sur laquelle on a cliqué. Il faudra utiliser pour cela la méthode =find_below(item)= pour trouver la forme en dessous d'une autre.
